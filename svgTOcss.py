import xml.sax

""" This parser reads .svg files. The output are coordinates, formatted to
    CSS clip-paths for polygons."""

class Coordinates( xml.sax.ContentHandler ):
    def __init__(self):
        self.CurrentData = ""


    def startElement(self, tag, attributes):

        numbers = ('1234567890.,- ')
        raw_coordinates = ""
        coordinates = ""
        self.CurrentData = tag

        # This section adds layer information
        # In the future, the program can identify animation stages by layer information
        # if tag == "g":
            # layer = attributes["inkscape:label"]
            # if layer == "" string aus eingabe! oder hardcode?
            # target.write("***{}***\n" .format(layer))
            # target.write("\n")

        if tag == "path":
            style = attributes["style"]

            # polygon_id is the hexadecimal code of the stroke
            # polygons of the same id are different animation stages of the same polygon
            polygon_id = style[54:61]
            background = style[5:12]

            # only if the # is in the line, the path belongs to a polygon
            if style[5] == '#':

            # wrap css
                target.write("      .object{} {{\n" .format(polygon_id))
                target.write("        background: {};\n" .format(background))
                target.write("        position: absolute;\n")
                target.write("        height: 800px;\n")
                target.write("        width: 800px;\n")
                target.write("        animation: make_elephant{} 5s infinite;\n" .format(polygon_id))

            # parsing the coordinates
            content = attributes["d"]

            # to make css-coordinates from the svg-path, characters other then
            # numbers and commas have to be omitted
            for char in content:
                if char in numbers:
                    raw_coordinates += char

            raw_coordinates = raw_coordinates.replace(',', ' ')
            Liste = raw_coordinates.split()

            # the pixel number is reduced to 3 places and used as%
            for i in range(len(Liste)):
                if i%2 == 0:
                    coordinates += Liste[i][0:4] + "% "
                else:
                    coordinates += Liste[i][0:4] + "%, "

            # ....to get rid of the final comma
            coordinates = coordinates[0:-2]

            # wrapping css
            target.write("        clip-path: polygon({});\n" .format(coordinates))
            target.write("        }\n")
            target.write("        @keyframes make_elephant{} {{ \n" .format(polygon_id))
            target.write("          0% {\n")
            target.write("            background: {};\n".format(background))
            target.write("            clip-path: polygon({});\n" .format(coordinates))
            target.write("          }\n")
            # in the future, the following lines have to be generated by svgTOElefant.py
            # svgTOElefant.py has to open the index.html, read lines, search for polygon_id
            # and add the 100% animation stage.
            target.write("          100% {\n")
            target.write("            background: {};\n".format(background))
            target.write("            clip-path: polygon({});\n" .format(coordinates))
            target.write("          }\n")
            target.write("        }\n")
            target.write("\n")

    def endElement(self, tag):
      self.CurrentData = ""

# File operations
# This new file will be generated.
print ("so you wand to animate polygons?")
filename_target = input("Name the file where your css will be saved in: >")
target = open(filename_target, "w")

# This is the File containing the coordinates of the polygons
filename_origin = input("Name of the .svg file, contaning path data: >")
origin = open(filename_origin, "r")



if ( __name__ == "__main__"):
    parser = xml.sax.make_parser()
    parser.setFeature(xml.sax.handler.feature_namespaces, 0)
    Handler = Coordinates()
    parser.setContentHandler(Handler)

    parser.parse(origin)


target.close()
origin.close()

print ("The parser has finished parsing.")
